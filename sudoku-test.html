<!DOCTYPE html>
<html>
    <head>
        <title>
            Sudoku!
        </title>
    </head>
    <body style="overflow: hidden; margin: 0px">
        <canvas style="background-color:black;" id="canvas"></canvas>
        
        <script>
            // Get the HTML Canvas element!
            let canvas = document.getElementById("canvas");
            let context = canvas.getContext("2d");

            // Initializes the Game Variables
            let minimumSideLength;
            let thickLineWidth = 10;
            let thinLineWidth = 2;

            // Resize the canvas when the window changes size.
            resize();
            window.addEventListener('resize', resize);
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                minimumSideLength = Math.min(canvas.width, canvas.height);
            }

            // Gets the mouse position at all times
            let mouseX;
            let mouseY;
            document.addEventListener('mousemove', event => {
                mouseX = event.clientX
                mouseY = event.clientY
            });

            // Generate a random sudoku board! The actual algorithm is taken from https://stackoverflow.com/questions/6924216/how-to-generate-sudoku-boards-with-unique-solutions in bits & pieces
            // Hey, if you are reading this code, pls tell me if I could make this algorithm better!

            // This is the initial board. This could also be used on it's own as an initial board, but we're gonna shuffle it while following the sudoku rules!
            let initialBoard = [
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
                [4, 5, 6, 7, 8, 9, 1, 2, 3],
                [7, 8, 9, 1, 2, 3, 4, 5, 6],
                [2, 3, 1, 5, 6, 4, 8, 9, 7],
                [5, 6, 4, 8, 9, 7, 2, 3, 1],
                [8, 9, 7, 2, 3, 1, 5, 6, 4],
                [3, 1, 2, 6, 4, 5, 9, 7, 8],
                [6, 4, 5, 9, 7, 8, 3, 1, 2],
                [9, 7, 8, 3, 1, 2, 6, 4, 5]
            ];

            // Create a row, column, & digit order to shuffle
            let temporaryArray = shuffleArray([shuffleArray([1, 2, 3]), shuffleArray([4, 5, 6]), shuffleArray([7, 8, 9])]);
            let rowOrder = temporaryArray[0].concat(temporaryArray[1].concat(temporaryArray[2]));
            temporaryArray = shuffleArray([shuffleArray([1, 2, 3]), shuffleArray([4, 5, 6]), shuffleArray([7, 8, 9])]);
            let columnOrder = temporaryArray[0].concat(temporaryArray[1].concat(temporaryArray[2]));
            let digitOrder = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            
            // Now to assemble the board!
            let currentBoard = [];
            for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                temporaryArray = [];
                for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                    // this is array hell
                    temporaryArray.push(digitOrder[initialBoard[columnOrder[columnIndex] - 1][rowOrder[rowIndex] - 1] - 1]);
                }
                currentBoard.push(temporaryArray);
            }

            
            // Now time to randomly start popping numbers out! Right now we're gonna make a list of the order of positions we'll remove.
            temporaryArray = [];
            for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                    temporaryArray.push([columnIndex, rowIndex]);
                }
            }
            temporaryArray = shuffleArray(temporaryArray);

            // Start to remove the positions, & if the board has multiple solutions, undo the removing.
            
            let solutionBoard = clone2DArray(currentBoard);
        
            for (let index = 0; index < 3; index++) {
                currentBoard[temporaryArray[index][0]][temporaryArray[index][1]] = "0";
            }
            

            
            // For some reason, when doing array = array2, editing one edits the other, so, uh, this is the fixer function for that. Something about references idk. Expected output: Another clone of the array passed in
            function clone2DArray(array) {
                return JSON.parse(JSON.stringify(array));
            }

            // this code is just taken from online.
            function solver(board) {
                // OK what if I just stringify the board?
                let test = JSON.parse(board)
                
                for(let i=0; i<9; i++){
                    for(let j=0; j<9; j++){

                        //Need to replace the cell with value if the cell is empty.
                        if(test[i][j] == '.'){
                            for(let val=1; val<10; val++){

                                //Checks with every possible value.
                                if(validateDigit(test, i, j, val)){
                                    test[i][j] = val
                                    if(solver(JSON.stringify(test))){
                                        return true
                                    }
                                    test[i][j] = '.'
                                }
                            }
                            return false
                        }
                    }
                }
                return true
            }

            /*
            // ok this time it's gotta work. Expected outcome: a boolean of if there is a solution
            // still doesn't work ;-;
            function solveSudoku(board) {
                console.log(board);
                let emptySpotsRemaining = true;
                let cantFillMoreSpots = false;
                let digitsArray = [];
                while (emptySpotsRemaining && !cantFillMoreSpots) {
                    emptySpotsRemaining = false;
                    cantFillMoreSpots = true;

                    // For each spot
                    for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                        for (let rowIndex = 0; rowIndex < 9; rowIndex++) {

                            // If the spot is empty
                            if (board[columnIndex][rowIndex] == 0) {

                                // For each digit
                                for (let digitIndex = 0; digitIndex < 9; digitIndex++) {
                                    
                                    // If you can put the digit in the spot
                                    if (validateDigit(board, columnIndex, rowIndex, digitIndex + 1)) {
                                        
                                        // Add the digit to the digits array
                                        digitsArray.push(digitIndex + 1);
                                    }
                                }
                            
                                // If the digits array has only one element
                                if (digitsArray.length == 1) {

                                    // Set the spot to that digit.
                                    board[columnIndex][rowIndex] = digitsArray[0];
                                    cantFillMoreSpots = false;
                                } else {
                                    emptySpotsRemaining = true;
                                }
                            }
                        }
                    }
                }
                if (emptySpotsRemaining) {
                    return false;
                } else {
                    return true;
                }
            }
            */

            /*
            // This function will (recursively :D) solve a sudoku board! Expected output: The amount of solutions there are.
            // This function does not work for some reason :(
            function solveSudoku(board) {
                find = [];
                for (let columnIndex = 0; columnIndex < 9; columnIndex++) {    
                    for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                        if (board[columnIndex][rowIndex] == 0) {
                            find.push([columnIndex, rowIndex]);
                        }
                    }
                }
                if (find.length == 0) {
                    return 1;
                }
                
                let count = 0;
                for (let index = 0; index < find.length; index++) {      
                    column = find[index][0];
                    row = find[index][1];
                    for (let digitIndex = 1; digitIndex < 10; digitIndex++) {
                        if (validateDigit(board, column, row, digitIndex)) {
                            board[column][row] = digitIndex;          
                            count += solveSudoku(clone2DArray(board));
                            board[column][row] = 0;
                        }
                    }
                }

                return count;
            }
            */

            // This function will validate if a number can be placed in a cell. Expected output: A boolean value
            function validateDigit(board, x, y, digit) {
                let output = true;
                for (let index = 0; index < 9; index++) {
                    if (board[x][index] == digit || board[index][y] == digit) {
                        output == false;
                    }
                }

                let xSection = Math.floor(x / 3);
                let ySection = Math.floor(y / 3);
                for (let columnIndex = 0; columnIndex < 3; columnIndex++) {
                    for (let rowIndex = 0; rowIndex < 3; rowIndex++) {
                        if (board[columnIndex + (xSection * 3)][rowIndex + (ySection * 3)] == digit) {
                            output = false;
                        }
                    }
                }
                
                return output;
            }

            // A helper function to randomly shuffle an array! Expected output: A shuffled version of the array
            function shuffleArray(array) {
                let outputArray = [];
                while (array.length > 0) {
                    let randomIndex = Math.floor(Math.random() * array.length);
                    outputArray.push(array[randomIndex]);
                    array.splice(randomIndex, 1);
                }
                return outputArray;
            }

            // This will be where most of the game's code takes place! :D
            function main(currentTime) {

                

                // Rendering code!

                // Clear the canvas
                context.clearRect(0, 0, canvas.width, canvas.height);

                // Add all of the highlighting on the board!
                context.fillStyle = "rgba(255, 255, 255, 0.5)";
                for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                    for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                        if (mouseX > (columnIndex + 1) * (minimumSideLength / 11) && mouseY > (rowIndex + 1) * (minimumSideLength / 11) && mouseX < (columnIndex + 2) * (minimumSideLength / 11) && mouseY < (rowIndex + 2) * (minimumSideLength / 11)) {
                            context.fillRect((columnIndex + 1) * (minimumSideLength / 11), (rowIndex + 1) * (minimumSideLength / 11), (minimumSideLength / 11), (minimumSideLength / 11))
                        }
                    }
                }

                // Drawing the board shape!
                for (let index = 0; index < 10; index++) {
                    context.beginPath();
                    context.lineWidth = index % 3 == 0 ? thickLineWidth : thinLineWidth;
                    context.strokeStyle = "white";
                    context.moveTo((index + 1) * minimumSideLength / 11, minimumSideLength / 11);
                    context.lineTo((index + 1) * minimumSideLength / 11, minimumSideLength / 11 * 10);
                    context.moveTo(minimumSideLength / 11, (index + 1) * minimumSideLength / 11);
                    context.lineTo(minimumSideLength / 11 * 10, (index + 1) * minimumSideLength / 11);
                    context.stroke();
                    context.closePath();
                }
                context.fillStyle = "white";
                for (let columnIndex = 0; columnIndex < 2; columnIndex++) {
                    for (let rowIndex = 0; rowIndex < 2; rowIndex++) {
                        context.beginPath();
                        context.arc(minimumSideLength / 11 * (columnIndex == 0 ? 1 : 10), minimumSideLength / 11 * (rowIndex == 0 ? 1 : 10), thickLineWidth / 2, 0, 2 * Math.PI);
                        context.fill();
                        context.closePath();
                    }
                }
                // Drawing the numbers on the board!
                context.textAlign = "center";
                context.font = minimumSideLength / 11 + "px sans-serif";
                context.textBaseline = "middle";
                for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                    for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                        if (currentBoard[columnIndex][rowIndex] == 0) {

                        } else {
                            context.fillText(currentBoard[columnIndex][rowIndex], (columnIndex + 1.5) * minimumSideLength / 11, (rowIndex + 1.6) * minimumSideLength / 11);
                        }
                    }
                }

                requestAnimationFrame(main);
            }
            requestAnimationFrame(main);
            
        </script>
    </body>
</html>