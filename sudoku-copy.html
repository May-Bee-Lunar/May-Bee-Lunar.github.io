<!DOCTYPE html>
<html>
    <head>
        <title>
            Sudoku!
        </title>
        <style>
            canvas {
                position:absolute;
                left:0;
                top:0;
            }
        </style>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=0"/>
    </head>
    <body style="overflow: hidden; margin: 0px">
        <canvas style="background-color:black;" id="background"></canvas>
        <canvas style="background-color:rgba(0, 0, 0, 0);" id="game"></canvas>
        <canvas style="background-color:rgba(0, 0, 0, 0);" id="menu"></canvas>
        
        <script>

            // Get the HTML Canvas element!
            let gameCanvas = document.getElementById("game");
            let gameContext = gameCanvas.getContext("2d");
            let backgroundCanvas = document.getElementById("background");
            let backgroundContext = backgroundCanvas.getContext("2d");
            let menuCanvas = document.getElementById("menu");
            let menuContext = menuCanvas.getContext("2d");

            // Initializes the Game Variables
            let minimumSideLength;
            let orientationMode;
            let selectedDigit = 1;
            let boardColor = "rgba(255, 255, 255, 1)"
            let thickLineWidth = 6;
            let thinLineWidth = 2;
            let textSizeMultiplier = 1;
            let time = 999;
            let maxTime = 999;
            let lastTimeMilliseconds = 0;
            let blurRadius = 4;
            let currentBoard = null;
            let generatingBoard = false;
            // 0 = Not compressed, 1 = A little compressed, 2 = Very very compressed like geez the window is practically a square
            let compressed;

            // States: play, title, pause
            let gameState = "title";

            // These are the variables on where to render stuff.
            class Element {
                constructor(x, y, width, height) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                }
            }
            let elementUnit;
            let boardElement = new Element(null, null, null, null);
            let timerElement = new Element(null, null, null, null);
            let menuButtonElement = new Element(null, null, null, null);
            let numberSelectorElement = new Element(null, null, null, null);
            let noteButtonElement = new Element(null, null, null, null);

            // A secret for later ;)
            let powerUpSelectorElement = new Element(null, null, null, null);

            // omg a lot of this is spaghetti code, eh, I'll clean it up later probably I suppose

            // Resize the canvas when the window changes size.
            resize();
            window.addEventListener('resize', resize);
            function resize() {
                gameCanvas.width = window.innerWidth;
                gameCanvas.height = window.innerHeight;
                backgroundCanvas.width = window.innerWidth;
                backgroundCanvas.height = window.innerHeight;
                menuCanvas.width = window.innerWidth;
                menuCanvas.height = window.innerHeight;
                minimumSideLength = Math.min(gameCanvas.width, gameCanvas.height);

                orientationMode = gameCanvas.width > gameCanvas.height ? "horizontal" : "vertical"

                if (orientationMode == "horizontal") {
                    compressed = gameCanvas.width / gameCanvas.height < 16.5 / 11 ? (gameCanvas.width / gameCanvas.height < 16.5 / 15 ? 2 : 1) : 0;
                    minimumSideLength = compressed > 0 ? gameCanvas.width / 3 * 2 : gameCanvas.height;
                    // Most elements on the canvas have an x, y, width, & height of multiples of the element unit. This is for my convenience for coding this.
                    elementUnit = minimumSideLength / 11;
                    switch (compressed) {
                        case 0:

                            boardElement.x = elementUnit;
                            boardElement.y = elementUnit;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit * 11;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit * 11;
                            numberSelectorElement.y = elementUnit * 3;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit * 15;
                            noteButtonElement.y = elementUnit * 3;
                            noteButtonElement.width = gameCanvas.width - elementUnit * 16;
                            noteButtonElement.height = elementUnit * 3;
                            if (noteButtonElement.width < elementUnit) {
                                noteButtonElement.x = gameCanvas.width - elementUnit * 2;
                                noteButtonElement.width = elementUnit;
                            }
                            
                            break;
                        case 1:

                            boardElement.x = elementUnit;
                            boardElement.y = (gameCanvas.height - elementUnit * 9) / 2;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit * 11;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;
                            if (gameCanvas.height / elementUnit > 13) {
                                timerElement.x = elementUnit
                                boardElement.y = elementUnit * 3;
                            }

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit * 11;
                            numberSelectorElement.y = elementUnit * 3;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit * 14;
                            noteButtonElement.y = elementUnit * 3;
                            noteButtonElement.width = gameCanvas.width - elementUnit * 15;
                            noteButtonElement.height = elementUnit * 3;
                            break;
                        case 2:
                            boardElement.x = elementUnit;
                            boardElement.y = elementUnit;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit * 11;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit * 11 + (gameCanvas.width - elementUnit * 15) / 2;
                            numberSelectorElement.y = elementUnit * 3;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit * 11;
                            noteButtonElement.y = elementUnit * 7;
                            noteButtonElement.width = gameCanvas.width - elementUnit * 12;
                            noteButtonElement.height = elementUnit * 3;
                            break;
                    }
                } else if (orientationMode == "vertical") {
                    compressed = gameCanvas.width / gameCanvas.height > 11 / 18 ? (gameCanvas.width / gameCanvas.height > 15 / 17 ? 2 : 1) : 0;
                    minimumSideLength = compressed < 2 ? gameCanvas.width : gameCanvas.height / 17 * 11;
                    if (compressed == 1) {
                        minimumSideLength = Math.min(gameCanvas.height / 17 * 11, gameCanvas.width)
                    }
                    elementUnit = minimumSideLength / 11;
                    switch (compressed) {
                        case 0:

                            boardElement.x = elementUnit;
                            boardElement.y = elementUnit * 3;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit;
                            numberSelectorElement.y = elementUnit * 13;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit;
                            noteButtonElement.y = elementUnit * 17;
                            noteButtonElement.width = elementUnit * 3;
                            noteButtonElement.height = gameCanvas.height - elementUnit * 18;
                            if (gameCanvas.width / gameCanvas.height > 11 / 19) {
                                noteButtonElement.y = elementUnit * 16;
                                noteButtonElement.height = gameCanvas.height - elementUnit * 17
                            }
                            
                            break;
                        case 1:

                            boardElement.y = elementUnit * 3;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;
                            boardElement.x = (gameCanvas.width - boardElement.width) / 2

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit;
                            numberSelectorElement.y = gameCanvas.height - elementUnit * 4;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit * 4;
                            noteButtonElement.y = gameCanvas.height - elementUnit * 4;
                            noteButtonElement.width = elementUnit * 2;
                            noteButtonElement.height = elementUnit * 3;
                            break;
                        case 2:
                            boardElement.x = elementUnit;
                            boardElement.y = elementUnit * 3;
                            boardElement.width = elementUnit * 9;
                            boardElement.height = elementUnit * 9;

                            // These values are for the clock icon itself, the actual timer is always a bit to the right.
                            // Height is used as the size and the width value goes unused.
                            timerElement.x = elementUnit;
                            timerElement.y = elementUnit;
                            timerElement.height = elementUnit;

                            menuButtonElement.x = gameCanvas.width - elementUnit * 2;
                            menuButtonElement.y = elementUnit;
                            menuButtonElement.width = elementUnit;
                            menuButtonElement.height = elementUnit

                            numberSelectorElement.x = elementUnit;
                            numberSelectorElement.y = elementUnit * 13;
                            numberSelectorElement.width = elementUnit * 3;
                            numberSelectorElement.height = elementUnit * 3;

                            noteButtonElement.x = elementUnit * 5;
                            noteButtonElement.y = elementUnit * 13;
                            noteButtonElement.width = elementUnit * 5;
                            noteButtonElement.height = elementUnit * 3;
                            break;
                    }
                }

                if (gameState == "pause") {
                    drawGame(true);
                }
            }

            // Gets the mouse position at all times
            let mouseX;
            let mouseY;
            document.addEventListener('mousemove', event => {
                mouseX = event.clientX
                mouseY = event.clientY
            });

            let batteryLevel;
            let batteryCharging;
            // Gets the device battery. Uhh... why I have this? Because! :D Copied from online but changed to remove the unnecessary information.
            navigator.getBattery().then((battery) => {
                batteryCharging = battery.charging;
                batteryLevel = battery.level;
                battery.addEventListener("chargingchange", () => {
                    batteryCharging = battery.charging;
                });
                battery.addEventListener("levelchange", () => {
                    batteryLevel = battery.level;
                });
            });

            // A helper function to randomly shuffle an array! Expected output: A shuffled version of the array
            function shuffleArray(array) {
                let outputArray = [];
                while (array.length > 0) {
                    let randomIndex = Math.floor(Math.random() * array.length);
                    outputArray.push(array[randomIndex]);
                    array.splice(randomIndex, 1);
                }
                return outputArray;
            }

            // A simple helper function to turn x & y cords into an index number. Expected output: An index value from 0 - 80.
            function cordsToIndex(x, y) {
                return (x + y * 9);
            }

            // Another helper function to return a string with a character changed at an index. Expected output: The string with the character at the index.
            function changeCharAtIndex(string, index, character) {
                return string.substr(0, index) + character + string.substr(index + 1);
            }

            // this code is just taken from online. after so long of trying i just gave up.
            // Of course with modifications to make the function work with a string instead of a 2d array and to return a solved board. A lot of modifications.
            // Expected output: One solution to the solved board. If there are multiple solutions, both functions will return different ones. If there are none, returns "No solution! :("
            function solver(board) {
                for(let index = 0; index < 81; index++){

                    //Need to replace the cell with value if the cell is empty.
                    if(board.charAt(index) == "0"){
                        for(let digit = 1; digit < 10; digit++){

                            //Checks with every possible value.
                            if(validateDigit(board, index, digit.toString())){
                                board = changeCharAtIndex(board, index, digit);
                                test = solver(board);
                                if(test != "No solution! :("){
                                    return test;
                                }
                                board = changeCharAtIndex(board, index, "0");
                            }
                        }
                        return "No solution! :(";
                    }

                }
                return board;
            }
            function altSolver(board) {
                for(let index = 0; index < 81; index++){
                    //Need to replace the cell with value if the cell is empty.
                    if(board.charAt(index) == "0"){
                        for(let digit = 9; digit >= 1; digit--){
                            //Checks with every possible value.
                            if(validateDigit(board, index, digit.toString())){
                                board = changeCharAtIndex(board, index, digit);
                                test = altSolver(board);
                                if(test != "No solution! :("){
                                    return test;
                                }
                                board = changeCharAtIndex(board, index, "0");
                            }
                        }
                        return "No solution! :(";
                    }

                }
                return board;
            }
            
            // This function will validate if a number can be placed in a cell. Expected output: A boolean value
            function validateDigit(board, index, digit) {
                let x = index % 9;
                let y = Math.floor(index / 9)

                for (let index = 0; index < 9; index++) {
                    if (board.charAt(cordsToIndex(x, index)) == digit || board.charAt(cordsToIndex(index, y)) == digit) {
                        return false;
                    }
                }

                let xSection = Math.floor(x / 3);
                let ySection = Math.floor(y / 3);
                for (let columnIndex = 0; columnIndex < 3; columnIndex++) {
                    for (let rowIndex = 0; rowIndex < 3; rowIndex++) {
                        if (board.charAt(cordsToIndex(columnIndex + (xSection * 3), rowIndex + (ySection * 3))) == digit) {
                            return false;
                        }
                    }
                }
                
                return true;
            }

            // LET'S GO IT ACTUALLY MAKES SOLVABLE BOARDS I NEVER WANT TO LOOK AT THIS CODE AGAIN this took so long
            // Expected output: A sudoku puzzle with 1 solution with 0 to represent empty spots, & about 25 (usually 20 - 30) filled in spots.
            function generateBoard() {
                // Generate a random sudoku board! The actual algorithm is taken from https://stackoverflow.com/questions/6924216/how-to-generate-sudoku-boards-with-unique-solutions in bits & pieces
                // Hey, if you are reading this code, pls tell me if I could make this algorithm better!

                // This is the initial board. This could also be used on it's own as an initial board, but we're gonna shuffle it while following the sudoku rules!
                let initialBoard = "123456789456789123789123456231564897564897231897231564312645978645978312978312645";
                // hm this isn't good enough (every 1x3 row/column with the same digits has... the same digits) lemme try to randomly make the initial board.
                initialBoard = "000000000000000000000000000000000000000000000000000000000000000000000000123456789"
                
                for (let index = 0; index < 72; index++) {
                    let digitOrder = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9])

                    for (let digitIndex = 0; digitIndex < 9; digitIndex++) {
                        if (initialBoard.charAt(index) == "0") {
                            if (validateDigit(initialBoard, index, digitOrder[digitIndex])) {
                                initialBoard = changeCharAtIndex(initialBoard, index, digitOrder[digitIndex]);
                                if (solver(initialBoard) == "No solution! :(") {
                                    initialBoard = changeCharAtIndex(initialBoard, index, "0");
                                }
                            }
                        }
                    }
                }

                
                // Create a row, column, & digit order to shuffle
                let temporaryArray = shuffleArray([shuffleArray([0, 1, 2]), shuffleArray([3, 4, 5]), shuffleArray([6, 7, 8])]);
                let rowOrder = temporaryArray[0].concat(temporaryArray[1].concat(temporaryArray[2]));
                temporaryArray = shuffleArray([shuffleArray([0, 1, 2]), shuffleArray([3, 4, 5]), shuffleArray([6, 7, 8])]);
                let columnOrder = temporaryArray[0].concat(temporaryArray[1].concat(temporaryArray[2]));
                digitOrder = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);

                
                // Now to assemble the board!
                let outputBoard = "";
                for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                    for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                        outputBoard = outputBoard.concat(digitOrder[Number(initialBoard.charAt(cordsToIndex(columnOrder[columnIndex], rowOrder[rowIndex]))) - 1]);
                    }
                }
                
                
                // Now time to randomly start popping numbers out! Right now we're gonna make an array of the order of positions we'll remove.
                let removeNumberList = [];
                for (let index = 0; index < 81; index++) {
                    removeNumberList.push(index);
                }
                removeNumberList = shuffleArray(removeNumberList);

                // Start to remove the positions, & if the board has multiple solutions, undo the removing.
                let solutionBoard = outputBoard;
                
                for (let index = 0; index < 81; index++) {
                    outputBoard = changeCharAtIndex(outputBoard, removeNumberList[index], "0");

                    // The solver and alt solver try to find solutions from opposite directions kinda, so if they return the same solution, it's the only solution.
                    if (solver(outputBoard) != altSolver(outputBoard)) {
                        //console.log(altSolver(outputBoard))
                        outputBoard = changeCharAtIndex(outputBoard, removeNumberList[index], solutionBoard.charAt(removeNumberList[index]));
                    }
                }

                return outputBoard;
            }

            // A function to test if the mouse is in a given area. Expected output: A true or false statement.
            function mouseOverlap(x, y, width, height) {
                return (mouseX > x && mouseX < x + width && mouseY > y && mouseY < y + height) ? true : false
                    
            }

            if (localStorage.getItem("currentBoard") != null) {
                currentBoard = localStorage.getItem("currentBoard");
                solutionBoard = solver(currentBoard);
                time = localStorage.getItem("currentTime")
            }

            document.addEventListener("click", click)
            // This is where all the code for clicks is! (basically all input)
            function click(event) {
                switch (gameState) {
                    case "play":
                        // Selecting a number
                        if (mouseOverlap(numberSelectorElement.x, numberSelectorElement.y, numberSelectorElement.width, numberSelectorElement.height)) {
                            let col = Math.floor((mouseX - numberSelectorElement.x) / (numberSelectorElement.width / 3))
                            let row = Math.floor((mouseY - numberSelectorElement.y) / (numberSelectorElement.height / 3))
                            selectedDigit = col % 3 + row * 3 + 1

                        // Inputs to the board
                        } else if (mouseOverlap(boardElement.x, boardElement.y, boardElement.width, boardElement.height)) {
                            let index = cordsToIndex(Math.floor((mouseX - boardElement.x) / (boardElement.width / 9)), Math.floor((mouseY - boardElement.y) / (boardElement.height / 9)))
                            if (currentBoard.charAt(index) == 0) {
                                if (selectedDigit == solutionBoard.charAt(index)) {
                                    currentBoard = changeCharAtIndex(currentBoard, index, selectedDigit)
                                }
                                else {
                                    time -= 50;
                                }
                            }
                        } else if (mouseOverlap(menuButtonElement.x, menuButtonElement.y, menuButtonElement.width, menuButtonElement.height)) {
                            gameState = "pause";
                            drawGame(true);

                        }
                        break;
                    case "pause":
                        if (mouseOverlap(menuCanvas.width / 6, menuCanvas.height / 12 * 4.9, menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)) {
                            gameState = "play"
                            gameContext.filter = "none"
                            menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height)
                            lastTimeMilliseconds = document.timeline.currentTime
                        }
                        else if (mouseOverlap(menuCanvas.width / 6, menuCanvas.height / 12 * 7.9, menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)) {
                            gameState = "title"
                            gameContext.filter = "none"
                            gameContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height)
                            menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height)
                            lastTimeMilliseconds = document.timeline.currentTime
                        }
                        break;
                    case "title":
                        for (let index = 0; index < 6; index++) {
                            if (mouseOverlap(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 2.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)) {
                                switch (index) {
                                    case 0:
                                        if (currentBoard != null) {
                                            lastTimeMilliseconds = document.timeline.currentTime
                                            gameState = "play"
                                            menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
                                        }
                                        break;
                                    case 1:
                                        //currentBoard = generateBoard();
                                        currentBoard = localStorage.getItem("boardCache").substring(0, 81);
                                        localStorage.setItem("boardCache", localStorage.getItem("boardCache").substring(81))
                                        solutionBoard = solver(currentBoard);
                                        time = 999
                                        lastTimeMilliseconds = document.timeline.currentTime
                                        gameState = "play"
                                        menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
                                        break;
                                    case 2:
                                        break;
                                    case 3:
                                        break;
                                    case 4:
                                        break;
                                    case 5:
                                        if (confirm("Are you sure you want to quit the game? (apparently I can't just close the tab sadly so this just redirects you to google.)")) {
                                            window.location.replace('http://google.com');
                                        }
                                        break;
                                }
                            }
                        }
                }
                
            }

            if (localStorage.getItem("boardCache") == null) {
                localStorage.setItem("boardCache", "");
            }

            const promise = new Promise((resolve, reject) => {
                resolve(generateBoard());
            })

            // This will be where most of the game's code takes place! :D (Update: Nevermind! Nope, not anymore)
            function main(currentTime) {

                if (!generatingBoard && localStorage.getItem("boardCache").length < 211) {
                    generatingBoard = true;
                    // Promises are confusing :(
                    console.log("Test1")

                    promise.then(value => {
                        localStorage.setItem("boardCache", localStorage.getItem("boardCache") + value);
                        generatingBoard = false;
                    
                    });

                    console.log("Test2")
                }

                // Rendering code!
                if (gameState == "play") {
                    drawGame(false)
                    localStorage.setItem("currentBoard", currentBoard);
                    localStorage.setItem("currentTime", time);
                }

                else if (gameState == "pause") {
                    menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
                    menuContext.strokeStyle = boardColor
                    menuContext.lineWidth = thickLineWidth

                    menuContext.fillStyle = boardColor
                    menuContext.textAlign = "center"
                    menuContext.textBaseline = "middle"

                    menuContext.font = menuCanvas.height / 6 + "px sans-serif"
                    menuContext.fillText("Paused!", menuCanvas.width / 2, menuCanvas.height / 12 * 3, menuCanvas.width);

                    for (let index = 0; index < 3; index++) {
                        if (mouseOverlap(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 4.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)) {
                            menuContext.fillStyle = "rgba(255, 255, 255, 0.5)"
                            menuContext.fillRect(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 4.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)
                            menuContext.fillStyle = boardColor
                        }
                        menuContext.strokeRect(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 4.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2);
                    }

                    menuContext.font = menuCanvas.height / 12 + "px sans-serif"
                    menuContext.fillText("Resume", menuCanvas.width / 2, menuCanvas.height / 12 * 5.5, menuCanvas.width / 1.5);
                    menuContext.fillText("Options", menuCanvas.width / 2, menuCanvas.height / 12 * 7, menuCanvas.width / 1.5);
                    menuContext.fillText("Title Screen", menuCanvas.width / 2, menuCanvas.height / 12 * 8.5, menuCanvas.width / 1.5);

                    menuContext.textAlign = "right"
                    menuContext.textBaseline = "top";
                    menuContext.fillText(batteryLevel * 100 + "%", menuCanvas.width - menuCanvas.height / 100, menuCanvas.height / 100);
                }

                else if (gameState == "title") {
                    menuContext.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
                    menuContext.strokeStyle = boardColor
                    menuContext.lineWidth = thickLineWidth
                    menuContext.fillStyle = boardColor
                    menuContext.textAlign = "center"
                    menuContext.textBaseline = "middle"

                    menuContext.font = menuCanvas.height / 6 + "px sans-serif"
                    menuContext.fillText("May Sudoku!", menuCanvas.width / 2, menuCanvas.height / 12 * 1.5, menuCanvas.width);
                    menuContext.font = menuCanvas.height / 12 + "px sans-serif"

                    // Continue, New Game, Extras, Options, Credits, Exit
                    // In extras: Rougelike mode, Tutorial, Back, Achievements
                    let buttonList = ["Resume Game", "New Game", "Extras", "Options", "Credits", "Exit"];
                    for (let index = 0; index < 6; index++) {
                        if (mouseOverlap(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 2.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)) {
                            menuContext.fillStyle = "rgba(255, 255, 255, 0.5)"
                            menuContext.fillRect(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 2.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2)
                            menuContext.fillStyle = boardColor
                        }
                        menuContext.fillText(buttonList[index], menuCanvas.width / 2, menuCanvas.height / 12 * (index * 1.5 + 3.5), menuCanvas.width / 1.5)
                        menuContext.strokeRect(menuCanvas.width / 6, menuCanvas.height / 12 * (index * 1.5 + 2.9), menuCanvas.width / 6 * 4, menuCanvas.height / 12 * 1.2);
                    }
                }

                
                

                requestAnimationFrame(main);
            }
            requestAnimationFrame(main);


            // After a bit of thinking about it I decided to move drawing the game itself to a different function.
            // Btw, the entire reason for this function and the multiple canvas layers is because making the game blur during pausing every frame really really *really* lags the pause menu.
            // haha i'm kinda dreading having to go back into this function to add more stuff lol
            function drawGame(paused) {
                if (paused) {                    
                    gameContext.filter = "blur(" + blurRadius + "px)"
                }
                
                gameContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                // Add all of the highlighting on the board!
                gameContext.fillStyle = "rgba(255, 255, 255, 0.5)";

                if (!paused) {
                    for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
                        for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
                            
                            if (mouseOverlap(boardElement.x + columnIndex * boardElement.width / 9, boardElement.y + rowIndex * boardElement.height / 9, boardElement.width / 9, boardElement.height / 9)) {
                                gameContext.fillRect(columnIndex * boardElement.width / 9 + boardElement.x, rowIndex * boardElement.height / 9 + boardElement.y, boardElement.width / 9, boardElement.height / 9)
                            }
                        }
                    }
                }

                // Drawing the board shape!
                gameContext.lineCap = "round";
                gameContext.strokeStyle = boardColor;
                gameContext.fillStyle = boardColor;

                for (let index = 0; index < 10; index++) {
                    gameContext.beginPath();
                    gameContext.lineWidth = index % 3 == 0 ? thickLineWidth : thinLineWidth;
                    gameContext.moveTo(index * (boardElement.width / 9) + boardElement.x, boardElement.y);
                    gameContext.lineTo(index * (boardElement.width / 9) + boardElement.x, boardElement.y + boardElement.height);
                    gameContext.moveTo(boardElement.x, index * (boardElement.height / 9) + boardElement.y);
                    gameContext.lineTo(boardElement.x + boardElement.width, index * (boardElement.height / 9) + boardElement.y);
                    gameContext.stroke();
                    gameContext.closePath();
                }
                
                // Drawing the numbers on the board!
                gameContext.textAlign = "center";
                gameContext.font = elementUnit * textSizeMultiplier + "px sans-serif";
                gameContext.textBaseline = "middle";

                if (!paused) {
                    for (let index = 0; index < 81; index++) {
                        if (currentBoard.charAt(index) == "0") {
                            // TO DO: Add notes here later!
                        } else {
                            gameContext.fillText(currentBoard.charAt(index), ((index % 9) + 0.5) * boardElement.width / 9 + boardElement.x, (Math.floor(index / 9) + 0.6) * boardElement.height / 9 + boardElement.y);
                        }
                    }
                    
                    time -= (document.timeline.currentTime - lastTimeMilliseconds) / 1000
                }
                lastTimeMilliseconds = document.timeline.currentTime

                // Drawing the... other stuff.
            
                

                // The timer
                gameContext.beginPath();
                gameContext.arc(timerElement.x + timerElement.height / 2, timerElement.y + timerElement.height / 2, timerElement.height / 2, 0, Math.PI * 2);
                if (timerElement.height / 2 - thickLineWidth > 0) {
                    gameContext.arc(timerElement.x + timerElement.height / 2, timerElement.y + timerElement.height / 2, timerElement.height / 2 - thickLineWidth, 0, Math.PI * 2, true);
                }
                gameContext.fill();
                gameContext.closePath();

                gameContext.lineWidth = thickLineWidth
                gameContext.beginPath();
                gameContext.moveTo(timerElement.x + timerElement.height / 2, timerElement.y + timerElement.height / 2);
                gameContext.lineTo(timerElement.x + timerElement.height / 2 + Math.sin((time / maxTime * Math.PI * 2) + Math.PI) * elementUnit / 4, timerElement.y + timerElement.height / 2 + Math.cos((time / maxTime * Math.PI * 2) + Math.PI) * elementUnit / 4);
                gameContext.stroke();
                gameContext.closePath();
                gameContext.textAlign = "left"
                gameContext.fillText(Math.ceil(time), timerElement.x + timerElement.height * 1.4, timerElement.y + timerElement.height * 0.6);

                // The menu button
                if (mouseOverlap(menuButtonElement.x, menuButtonElement.y, menuButtonElement.width, menuButtonElement.y) && !paused) {
                    gameContext.fillStyle = "rgba(255, 255, 255, 0.5)";
                    gameContext.fillRect(menuButtonElement.x, menuButtonElement.y, menuButtonElement.width, menuButtonElement.y);
                    gameContext.fillStyle = boardColor;
                }
                gameContext.beginPath();
                for (let index = -1; index < 2; index++) {
                    gameContext.moveTo(menuButtonElement.x + menuButtonElement.width * 0.25, menuButtonElement.y + menuButtonElement.height / 2 + menuButtonElement.height * index  * 0.2);
                    gameContext.lineTo(menuButtonElement.x + menuButtonElement.width * 0.75, menuButtonElement.y + menuButtonElement.height / 2 + menuButtonElement.height * index  * 0.2);
                }
                gameContext.stroke();
                gameContext.closePath();
                gameContext.strokeStyle = "white"
                gameContext.strokeRect(menuButtonElement.x + thickLineWidth / 2, menuButtonElement.y + thickLineWidth / 2, menuButtonElement.width - thickLineWidth, menuButtonElement.height - thickLineWidth)

                gameContext.textAlign = "center"
                gameContext.lineWidth = thickLineWidth;

                // The number selection
                for (let index = 0; index < 4; index++) {
                    gameContext.beginPath();
                    gameContext.lineWidth = index % 3 == 0 ? thickLineWidth : thinLineWidth;
                    gameContext.moveTo(index * (numberSelectorElement.width / 3) + numberSelectorElement.x, numberSelectorElement.y);
                    gameContext.lineTo(index * (numberSelectorElement.width / 3) + numberSelectorElement.x, numberSelectorElement.y + numberSelectorElement.height);
                    gameContext.moveTo(numberSelectorElement.x, index * (numberSelectorElement.height / 3) + numberSelectorElement.y);
                    gameContext.lineTo(numberSelectorElement.x + numberSelectorElement.width, index * (numberSelectorElement.height / 3) + numberSelectorElement.y);
                    gameContext.stroke();
                    gameContext.closePath();
                }
                for (let digitIndex = 0; digitIndex < 9; digitIndex++) {
                    if (mouseOverlap(numberSelectorElement.x + (digitIndex % 3) * numberSelectorElement.width / 3, numberSelectorElement.y + (digitIndex - digitIndex % 3) / 3 * numberSelectorElement.height / 3, numberSelectorElement.width / 3, numberSelectorElement.height / 3) && !paused) {
                        gameContext.fillStyle = "rgba(255, 255, 255, 0.5)";
                        gameContext.fillRect(numberSelectorElement.x + (digitIndex % 3) * numberSelectorElement.width / 3, numberSelectorElement.y + (digitIndex - digitIndex % 3) / 3 * numberSelectorElement.height / 3, numberSelectorElement.width / 3, numberSelectorElement.height / 3);
                        gameContext.fillStyle = boardColor;
                    } else if (selectedDigit == digitIndex + 1) {
                        gameContext.fillStyle = "rgba(255, 255, 255, 0.25)";
                        gameContext.fillRect(numberSelectorElement.x + (digitIndex % 3) * numberSelectorElement.width / 3, numberSelectorElement.y + (digitIndex - digitIndex % 3) / 3 * numberSelectorElement.height / 3, numberSelectorElement.width / 3, numberSelectorElement.height / 3);
                        gameContext.fillStyle = boardColor;
                    }
                    
                    gameContext.fillText(digitIndex + 1, numberSelectorElement.x + (digitIndex % 3 + 0.5) * numberSelectorElement.width / 3, numberSelectorElement.y + ((digitIndex - digitIndex % 3) / 3 + 0.6) * numberSelectorElement.height / 3)
                }

                // The hint button (the button doesn't do anything yet :()
                if (mouseOverlap(noteButtonElement.x, noteButtonElement.y, noteButtonElement.width, noteButtonElement.height) && !paused) {
                    gameContext.fillStyle = "rgba(255, 255, 255, 0.5)";
                    gameContext.fillRect(noteButtonElement.x, noteButtonElement.y, noteButtonElement.width, noteButtonElement.height);
                    gameContext.fillStyle = boardColor;
                }
                gameContext.strokeRect(noteButtonElement.x, noteButtonElement.y, noteButtonElement.width, noteButtonElement.height);

                if (paused) {
                    gameContext.fillStyle = "rgba(0, 0, 0, 0.5)"
                    gameContext.fillRect(0, 0, menuCanvas.width, menuCanvas.height);
                }
            }
        </script>
    </body>
</html>